/- Copyright © 2018–2025 Anne Baanen, Alexander Bentkamp, Jasmin Blanchette,
Johannes Hölzl, and Jannis Limperg. See `LICENSE.txt`. -/

import LoVe.LoVe07_EffectfulProgramming_Demo


/- # LoVe Homework 3 (10 points): Inductive Types, the Recursor and the Inductor, and Monads

Replace the placeholders (e.g., `:= sorry`) with your solutions. -/


set_option autoImplicit false
set_option tactic.hygienic false

namespace LoVe


/- ## Question 1 (2.5 points, 0.5 each): The Recursor and the Inductor for Nat -/

/- Lean automatically generates recursors for all inductive types -/
/- We will both work with the autogenerated ones, and define our recursors for fun.
-/

/- 1.1 (0.5 points). Fill in the function body of the natural number recursor rec_Nat[τ](e, ez, x.y.eb) from lecture 3. -/
def recNat  (τ : Type) (e : Nat) (ez : τ) (eb : Nat → τ → τ) : τ := sorry


/- 1.2 (0.5 points). Use your recursor to define a function double that doubles a natural number
 You may not use the + or * operators. You may use Nat.succ -/
def double (x : Nat) : Nat := sorry


-- maybe check if your double works
#eval double 0
#eval double 10
#eval double 20
#eval double 30

/- 1.3 (0.5 points). Prove that your recursor behaves the same with the built-in Nat.rec -/
theorem recNatWorks : (τ : Type) → (e : Nat) → (ez : τ) → (eb : Nat → τ → τ) → recNat τ e ez eb = Nat.rec (motive := λ_ => τ) (zero := ez) (succ := eb) e := sorry

/- 1.4 (0.5 points). Fill in the function body of the natural number inductor from lecture 7.
 You may want to check the recNatWorks theorem statement to see how the Nat.rec (which is almost identical to indNat) is used -/
def indNat  (motive : Nat → Type) (ez : motive 0) (eb : (x : Nat) → motive x → motive (x + 1)) (e : Nat): motive e := sorry

#print Eq.rec


/- 1.5 (0.5 points) Use `indNat` to define a function `dec` that subtracts one from a natural number.
 Examples: dec 10 = 9, dec 9 = 8, and dec 0 = 0.
 You may not use the + or * operators. You may use Nat.succ -/
def dec (x : Nat) : Nat := sorry

-- maybe check if your double' works
#eval dec 0
#eval dec 10
#eval dec 20
#eval dec 30



/- ## Question 2 (2 points): The Inductors for Eq and Or -/

-- Note that the arguments Eq.rec is slightly different than the inductor
-- we have seen in class.


-- Here is an example usage of using @Eq.rec
theorem propeq (α : Type) (a b : α) (P : α → Prop) (hab : a = b) : P a → P b :=
  @Eq.rec α a (λ(b : α) (hab : a = b) => P a → P b) (λ (hpa : P a) => hpa) b hab

/- 2.1 (0.5 points). Prove that `Eq` is symmetric using `@Eq.rec`.
   (Note: the `@` symbol forces you to supply all implicit arguments explicitly.) -/
theorem symeq (τ : Type) (a b : τ) (hab : a = b) : b = a := sorry

/- 2.2 (0.5 points). Prove that `Eq` is transitive using `@Eq.rec` -/
theorem transeq (τ : Type) (a b c : τ) (hab : a = b) (hbc : b = c) : a = c := sorry

/- 2.3 (0.5 points). Prove that if `x = y` then `f x = f y` using `@Eq.rec`. -/
theorem funceq  (α β: Type) (a b : α) (f : α → β) (hab : a = b) : f a = f b := sorry

/- 2.4 (0.5 points). Prove that if `a ∨ b` then `b ∨ a` using `@Or.rec` -/
theorem symor (a b : Prop) (hab : a ∨ b) : b ∨ a := sorry

/- ## Question 3 (3.5 points): Better Exceptions

The __error monad__ stores either a value of type `α` or an error of type `ε`.
This corresponds to the following type: -/

inductive Error (ε α : Type) : Type
  | good : α → Error ε α
  | bad  : ε → Error ε α

/- The error monad generalizes the option monad seen in the lecture. The
`Error.good` constructor, corresponding to `Option.some`, stores the current
result of the computation. But instead of having a single bad state
`Option.none`, the error monad has many bad states of the form `Error.bad e`,
where `e` is an "exception" of type `ε`.

3.1 (0.5 point). Complete the definitions of the `pure` and `bind` operations on
the error monad: -/

def Error.pure {ε α : Type} : α → Error ε α := sorry


def Error.bind {ε α β : Type} : Error ε α → (α → Error ε β) → Error ε β := sorry


/- The following type class instance makes it possible to use `pure`, `>>=`,
and `do` notations in conjunction with error monads: -/

instance Error.Pure {ε : Type} : Pure (Error ε) :=
  { pure := Error.pure }

instance Error.Bind {ε : Type} : Bind (Error ε) :=
  { bind := Error.bind }

/- 3.2 (2 points). Prove the three laws for the error monad. -/

theorem Error.pure_bind {ε α β : Type} (a : α) (f : α → Error ε β) :
    (pure a >>= f) = f a := sorry

theorem Error.bind_pure {ε α : Type} (ma : Error ε α) :
    (ma >>= pure) = ma := sorry

theorem Error.bind_assoc {ε α β γ : Type} (f : α → Error ε β)
      (g : β → Error ε γ) (ma : Error ε α) :
    ((ma >>= f) >>= g) = (ma >>= (fun a ↦ f a >>= g)) := sorry

/- 3.3 (1 point). Define the following two operations on the error monad.

* The `throw` operation raises an exception `e`, leaving the monad in a bad
  state storing `e`.

* The `catch` operation can be used to recover from an earlier exception. If the
  monad is currently in a bad state storing `e`, `catch` invokes some
  exception-handling code (the second argument of `catch`), passing `e` as
  argument; this code might in turn raise a new exception. If `catch` is applied
  to a good state, the monad remains in the good state. -/

def Error.throw {ε α : Type} : ε → Error ε α := sorry


def Error.catch {ε α : Type} : Error ε α → (ε → Error ε α) → Error ε α := sorry





/- ## Question 4 (2 points): Properties of `mmap`

We will prove some properties of the `mmap` function introduced in the
lecture's demo. -/

#check mmap

/- 4.1 (1 point). Prove the following identity law about `mmap` for an
arbitrary monad `m`.

Hint: You will need the theorem `LawfulMonad.pure_bind` in the induction step. -/

theorem mmap_pure {m : Type → Type} [LawfulMonad m] {α : Type} (as : List α) :
    mmap (pure : α → m α) as = pure as := sorry
/- Commutative monads are monads for which we can reorder actions that do not
depend on each other. Formally: -/

class CommLawfulMonad (m : Type → Type)
  extends LawfulMonad m :=
  bind_comm {α β γ δ : Type} (ma : m α) (f : α → m β) (g : α → m γ)
      (h : α → β → γ → m δ) :
    (ma >>= (fun a ↦ f a >>= (fun b ↦ g a >>= (fun c ↦ h a b c)))) =
    (ma >>= (fun a ↦ g a >>= (fun c ↦ f a >>= (fun b ↦ h a b c))))

/- 4.2 (1 point). Complete the proof that `Option` is a commutative monad. -/

theorem Option.bind_comm {α β γ δ : Type} (ma : Option α) (f : α → Option β)
      (g : α → Option γ) (h : α → β → γ → Option δ) :
    (ma >>= (fun a ↦ f a >>= (fun b ↦ g a >>= (fun c ↦ h a b c)))) =
    (ma >>= (fun a ↦ g a >>= (fun c ↦ f a >>= (fun b ↦ h a b c)))) := sorry


end LoVe
